"use strict";
// Analyze Health Trends API Endpoint
// Requirements: 1.5, 10.1, 10.2, 10.5 - Generate health trends and visualizations
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = handler;
const types_1 = require("../shared/types");
const timestream_client_1 = require("../shared/timestream-client");
const access_control_1 = require("../shared/access-control");
const audit_logger_1 = require("../shared/audit-logger");
/**
 * Calculate trend direction based on data points
 */
function calculateTrend(dataPoints) {
    if (dataPoints.length < 2) {
        return 'stable';
    }
    // Calculate linear regression slope
    const n = dataPoints.length;
    const xValues = dataPoints.map((_, i) => i);
    const yValues = dataPoints.map(dp => dp.value);
    const sumX = xValues.reduce((a, b) => a + b, 0);
    const sumY = yValues.reduce((a, b) => a + b, 0);
    const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
    const sumXX = xValues.reduce((sum, x) => sum + x * x, 0);
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    // Calculate average and standard deviation
    const avg = sumY / n;
    const variance = yValues.reduce((sum, y) => sum + Math.pow(y - avg, 2), 0) / n;
    const stdDev = Math.sqrt(variance);
    // Determine trend based on slope and variability
    const normalizedSlope = slope / (stdDev || 1);
    if (Math.abs(normalizedSlope) < 0.1) {
        return 'stable';
    }
    else if (normalizedSlope > 0.3) {
        return 'concerning';
    }
    else if (normalizedSlope > 0.1) {
        return 'declining';
    }
    else {
        return 'improving';
    }
}
/**
 * Generate analysis text based on trend
 */
function generateAnalysis(metric, trend, dataPoints) {
    if (dataPoints.length === 0) {
        return `No ${metric} data available for this time period.`;
    }
    const latest = dataPoints[dataPoints.length - 1].value;
    const earliest = dataPoints[0].value;
    const avg = dataPoints.reduce((sum, dp) => sum + dp.value, 0) / dataPoints.length;
    const metricName = metric.replace(/_/g, ' ');
    switch (trend) {
        case 'improving':
            return `Your ${metricName} is showing improvement. Current: ${latest.toFixed(1)}, Average: ${avg.toFixed(1)}. Keep up the good work!`;
        case 'stable':
            return `Your ${metricName} is stable. Current: ${latest.toFixed(1)}, Average: ${avg.toFixed(1)}. Continue monitoring regularly.`;
        case 'declining':
            return `Your ${metricName} shows a declining trend. Current: ${latest.toFixed(1)}, Average: ${avg.toFixed(1)}. Consider discussing with your healthcare provider.`;
        case 'concerning':
            return `Your ${metricName} shows concerning changes. Current: ${latest.toFixed(1)}, Average: ${avg.toFixed(1)}. Please consult your healthcare provider soon.`;
    }
}
/**
 * Generate visualization data for charts
 */
function generateVisualizationData(dataPoints) {
    return {
        labels: dataPoints.map(dp => dp.timestamp.toISOString()),
        values: dataPoints.map(dp => dp.value),
        chartType: 'line',
    };
}
/**
 * Analyze health trends for a user
 * GET /api/v1/health/trends/{userId}
 */
async function handler(event) {
    try {
        // Extract user info from authorizer context
        const requestingUserId = event.requestContext.authorizer?.principalId;
        const requestingUserType = event.requestContext.authorizer?.userType;
        if (!requestingUserId || !requestingUserType) {
            return (0, types_1.createErrorResponse)(401, 'Unauthorized: Missing user context');
        }
        // Get target user ID from path parameters
        const targetUserId = event.pathParameters?.userId;
        if (!targetUserId) {
            return (0, types_1.createErrorResponse)(400, 'Missing userId parameter');
        }
        // Check permissions
        const hasPermission = await (0, access_control_1.checkPermission)(requestingUserId, requestingUserType, targetUserId, 'vitals', 'read');
        if (!hasPermission) {
            await (0, audit_logger_1.logDataAccess)(requestingUserId, requestingUserType, targetUserId, 'vitals', 'read', false, ['trends'], { reason: 'Insufficient permissions' });
            return (0, types_1.createErrorResponse)(403, 'Forbidden: Insufficient permissions');
        }
        // Parse time range from query parameters
        const timeRangeParam = event.queryStringParameters?.timeRange || '7d';
        const endTime = new Date();
        let startTime;
        switch (timeRangeParam) {
            case '24h':
                startTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000);
                break;
            case '7d':
                startTime = new Date(endTime.getTime() - 7 * 24 * 60 * 60 * 1000);
                break;
            case '30d':
                startTime = new Date(endTime.getTime() - 30 * 24 * 60 * 60 * 1000);
                break;
            case '90d':
                startTime = new Date(endTime.getTime() - 90 * 24 * 60 * 60 * 1000);
                break;
            default:
                startTime = new Date(endTime.getTime() - 7 * 24 * 60 * 60 * 1000);
        }
        const timeRange = { start: startTime, end: endTime };
        // Query vital signs data
        const vitalSignsData = await (0, timestream_client_1.queryVitalSigns)(targetUserId, startTime, endTime);
        // Group data by measure name
        const groupedData = {};
        for (const record of vitalSignsData) {
            const measureName = record.measure_name;
            if (!groupedData[measureName]) {
                groupedData[measureName] = [];
            }
            groupedData[measureName].push({
                timestamp: new Date(record.time),
                value: parseFloat(record.value),
                source: record.source,
            });
        }
        // Generate trends for each metric
        const trends = [];
        const recommendations = [];
        for (const [metric, dataPoints] of Object.entries(groupedData)) {
            if (dataPoints.length === 0)
                continue;
            // Sort by timestamp
            dataPoints.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
            const trend = calculateTrend(dataPoints);
            const analysis = generateAnalysis(metric, trend, dataPoints);
            trends.push({
                metric,
                timeRange,
                dataPoints: dataPoints.map(dp => ({
                    timestamp: dp.timestamp,
                    value: dp.value,
                    source: dp.source,
                })),
                trend,
                analysis,
            });
            // Generate recommendations for concerning trends
            if (trend === 'concerning' || trend === 'declining') {
                recommendations.push(`Monitor ${metric.replace(/_/g, ' ')} closely and consult your healthcare provider.`);
            }
        }
        // Generate visualization data
        const visualizations = Object.entries(groupedData).map(([metric, dataPoints]) => ({
            metric,
            data: generateVisualizationData(dataPoints),
        }));
        // Log successful access
        await (0, audit_logger_1.logDataAccess)(requestingUserId, requestingUserType, targetUserId, 'vitals', 'read', true, ['trends'], {
            timeRange: timeRangeParam,
            metricsAnalyzed: Object.keys(groupedData),
        });
        return (0, types_1.createSuccessResponse)({
            userId: targetUserId,
            timeRange: {
                start: startTime.toISOString(),
                end: endTime.toISOString(),
            },
            trends,
            visualizations,
            recommendations,
            summary: `Analyzed ${trends.length} health metrics over ${timeRangeParam}`,
        });
    }
    catch (error) {
        console.error('Analyze health trends error:', error);
        return (0, types_1.createErrorResponse)(500, 'Internal server error');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5hbHl6ZS1oZWFsdGgtdHJlbmRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYW5hbHl6ZS1oZWFsdGgtdHJlbmRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxxQ0FBcUM7QUFDckMsa0ZBQWtGOztBQTRGbEYsMEJBcUpDO0FBOU9ELDJDQUFxRztBQUNyRyxtRUFBOEQ7QUFDOUQsNkRBQTJEO0FBQzNELHlEQUF1RDtBQUV2RDs7R0FFRztBQUNILFNBQVMsY0FBYyxDQUFDLFVBQXFEO0lBQzNFLElBQUksVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUMxQixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQsb0NBQW9DO0lBQ3BDLE1BQU0sQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUM7SUFDNUIsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVDLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFL0MsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEQsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEQsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FB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QUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ2hGLE1BQU07WUFDTixJQUFJLEVBQUUseUJBQXlCLENBQUMsVUFBVSxDQUFDO1NBQzVDLENBQUMsQ0FBQyxDQUFDO1FBRUosd0JBQXdCO1FBQ3hCLE1BQU0sSUFBQSw0QkFBYSxFQUNqQixnQkFBZ0IsRUFDaEIsa0JBQWtCLEVBQ2xCLFlBQVksRUFDWixRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksRUFDSixDQUFDLFFBQVEsQ0FBQyxFQUNWO1lBQ0UsU0FBUyxFQUFFLGNBQWM7WUFDekIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO1NBQzFDLENBQ0YsQ0FBQztRQUVGLE9BQU8sSUFBQSw2QkFBcUIsRUFBQztZQUMzQixNQUFNLEVBQUUsWUFBWTtZQUNwQixTQUFTLEVBQUU7Z0JBQ1QsS0FBSyxFQUFFLFNBQVMsQ0FBQyxXQUFXLEVBQUU7Z0JBQzlCLEdBQUcsRUFBRSxPQUFPLENBQUMsV0FBVyxFQUFFO2FBQzNCO1lBQ0QsTUFBTTtZQUNOLGNBQWM7WUFDZCxlQUFlO1lBQ2YsT0FBTyxFQUFFLFlBQVksTUFBTSxDQUFDLE1BQU0sd0JBQXdCLGNBQWMsRUFBRTtTQUMzRSxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsOEJBQThCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDckQsT0FBTyxJQUFBLDJCQUFtQixFQUFDLEdBQUcsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQzNELENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQW5hbHl6ZSBIZWFsdGggVHJlbmRzIEFQSSBFbmRwb2ludFxuLy8gUmVxdWlyZW1lbnRzOiAxLjUsIDEwLjEsIDEwLjIsIDEwLjUgLSBHZW5lcmF0ZSBoZWFsdGggdHJlbmRzIGFuZCB2aXN1YWxpemF0aW9uc1xuXG5pbXBvcnQgeyBBUElHYXRld2F5UHJveHlFdmVudCwgQVBJR2F0ZXdheVByb3h5UmVzdWx0IH0gZnJvbSAnYXdzLWxhbWJkYSc7XG5pbXBvcnQgeyBjcmVhdGVTdWNjZXNzUmVzcG9uc2UsIGNyZWF0ZUVycm9yUmVzcG9uc2UsIEhlYWx0aFRyZW5kLCBUaW1lUmFuZ2UgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgcXVlcnlWaXRhbFNpZ25zIH0gZnJvbSAnLi4vc2hhcmVkL3RpbWVzdHJlYW0tY2xpZW50JztcbmltcG9ydCB7IGNoZWNrUGVybWlzc2lvbiB9IGZyb20gJy4uL3NoYXJlZC9hY2Nlc3MtY29udHJvbCc7XG5pbXBvcnQgeyBsb2dEYXRhQWNjZXNzIH0gZnJvbSAnLi4vc2hhcmVkL2F1ZGl0LWxvZ2dlcic7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRyZW5kIGRpcmVjdGlvbiBiYXNlZCBvbiBkYXRhIHBvaW50c1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmVuZChkYXRhUG9pbnRzOiBBcnJheTx7IHRpbWVzdGFtcDogRGF0ZTsgdmFsdWU6IG51bWJlciB9Pik6ICdpbXByb3ZpbmcnIHwgJ3N0YWJsZScgfCAnZGVjbGluaW5nJyB8ICdjb25jZXJuaW5nJyB7XG4gIGlmIChkYXRhUG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gJ3N0YWJsZSc7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgbGluZWFyIHJlZ3Jlc3Npb24gc2xvcGVcbiAgY29uc3QgbiA9IGRhdGFQb2ludHMubGVuZ3RoO1xuICBjb25zdCB4VmFsdWVzID0gZGF0YVBvaW50cy5tYXAoKF8sIGkpID0+IGkpO1xuICBjb25zdCB5VmFsdWVzID0gZGF0YVBvaW50cy5tYXAoZHAgPT4gZHAudmFsdWUpO1xuXG4gIGNvbnN0IHN1bVggPSB4VmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICBjb25zdCBzdW1ZID0geVZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgY29uc3Qgc3VtWFkgPSB4VmFsdWVzLnJlZHVjZSgoc3VtLCB4LCBpKSA9PiBzdW0gKyB4ICogeVZhbHVlc1tpXSwgMCk7XG4gIGNvbnN0IHN1bVhYID0geFZhbHVlcy5yZWR1Y2UoKHN1bSwgeCkgPT4gc3VtICsgeCAqIHgsIDApO1xuXG4gIGNvbnN0IHNsb3BlID0gKG4gKiBzdW1YWSAtIHN1bVggKiBzdW1ZKSAvIChuICogc3VtWFggLSBzdW1YICogc3VtWCk7XG5cbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgYW5kIHN0YW5kYXJkIGRldmlhdGlvblxuICBjb25zdCBhdmcgPSBzdW1ZIC8gbjtcbiAgY29uc3QgdmFyaWFuY2UgPSB5VmFsdWVzLnJlZHVjZSgoc3VtLCB5KSA9PiBzdW0gKyBNYXRoLnBvdyh5IC0gYXZnLCAyKSwgMCkgLyBuO1xuICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuXG4gIC8vIERldGVybWluZSB0cmVuZCBiYXNlZCBvbiBzbG9wZSBhbmQgdmFyaWFiaWxpdHlcbiAgY29uc3Qgbm9ybWFsaXplZFNsb3BlID0gc2xvcGUgLyAoc3RkRGV2IHx8IDEpO1xuXG4gIGlmIChNYXRoLmFicyhub3JtYWxpemVkU2xvcGUpIDwgMC4xKSB7XG4gICAgcmV0dXJuICdzdGFibGUnO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRTbG9wZSA+IDAuMykge1xuICAgIHJldHVybiAnY29uY2VybmluZyc7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXplZFNsb3BlID4gMC4xKSB7XG4gICAgcmV0dXJuICdkZWNsaW5pbmcnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnaW1wcm92aW5nJztcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuYWx5c2lzIHRleHQgYmFzZWQgb24gdHJlbmRcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVBbmFseXNpcyhcbiAgbWV0cmljOiBzdHJpbmcsXG4gIHRyZW5kOiAnaW1wcm92aW5nJyB8ICdzdGFibGUnIHwgJ2RlY2xpbmluZycgfCAnY29uY2VybmluZycsXG4gIGRhdGFQb2ludHM6IEFycmF5PHsgdGltZXN0YW1wOiBEYXRlOyB2YWx1ZTogbnVtYmVyIH0+XG4pOiBzdHJpbmcge1xuICBpZiAoZGF0YVBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYE5vICR7bWV0cmljfSBkYXRhIGF2YWlsYWJsZSBmb3IgdGhpcyB0aW1lIHBlcmlvZC5gO1xuICB9XG5cbiAgY29uc3QgbGF0ZXN0ID0gZGF0YVBvaW50c1tkYXRhUG9pbnRzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBjb25zdCBlYXJsaWVzdCA9IGRhdGFQb2ludHNbMF0udmFsdWU7XG4gIGNvbnN0IGF2ZyA9IGRhdGFQb2ludHMucmVkdWNlKChzdW0sIGRwKSA9PiBzdW0gKyBkcC52YWx1ZSwgMCkgLyBkYXRhUG9pbnRzLmxlbmd0aDtcblxuICBjb25zdCBtZXRyaWNOYW1lID0gbWV0cmljLnJlcGxhY2UoL18vZywgJyAnKTtcblxuICBzd2l0Y2ggKHRyZW5kKSB7XG4gICAgY2FzZSAnaW1wcm92aW5nJzpcbiAgICAgIHJldHVybiBgWW91ciAke21ldHJpY05hbWV9IGlzIHNob3dpbmcgaW1wcm92ZW1lbnQuIEN1cnJlbnQ6ICR7bGF0ZXN0LnRvRml4ZWQoMSl9LCBBdmVyYWdlOiAke2F2Zy50b0ZpeGVkKDEpfS4gS2VlcCB1cCB0aGUgZ29vZCB3b3JrIWA7XG4gICAgY2FzZSAnc3RhYmxlJzpcbiAgICAgIHJldHVybiBgWW91ciAke21ldHJpY05hbWV9IGlzIHN0YWJsZS4gQ3VycmVudDogJHtsYXRlc3QudG9GaXhlZCgxKX0sIEF2ZXJhZ2U6ICR7YXZnLnRvRml4ZWQoMSl9LiBDb250aW51ZSBtb25pdG9yaW5nIHJlZ3VsYXJseS5gO1xuICAgIGNhc2UgJ2RlY2xpbmluZyc6XG4gICAgICByZXR1cm4gYFlvdXIgJHttZXRyaWNOYW1lfSBzaG93cyBhIGRlY2xpbmluZyB0cmVuZC4gQ3VycmVudDogJHtsYXRlc3QudG9GaXhlZCgxKX0sIEF2ZXJhZ2U6ICR7YXZnLnRvRml4ZWQoMSl9LiBDb25zaWRlciBkaXNjdXNzaW5nIHdpdGggeW91ciBoZWFsdGhjYXJlIHByb3ZpZGVyLmA7XG4gICAgY2FzZSAnY29uY2VybmluZyc6XG4gICAgICByZXR1cm4gYFlvdXIgJHttZXRyaWNOYW1lfSBzaG93cyBjb25jZXJuaW5nIGNoYW5nZXMuIEN1cnJlbnQ6ICR7bGF0ZXN0LnRvRml4ZWQoMSl9LCBBdmVyYWdlOiAke2F2Zy50b0ZpeGVkKDEpfS4gUGxlYXNlIGNvbnN1bHQgeW91ciBoZWFsdGhjYXJlIHByb3ZpZGVyIHNvb24uYDtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIHZpc3VhbGl6YXRpb24gZGF0YSBmb3IgY2hhcnRzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVmlzdWFsaXphdGlvbkRhdGEoZGF0YVBvaW50czogQXJyYXk8eyB0aW1lc3RhbXA6IERhdGU7IHZhbHVlOiBudW1iZXIgfT4pIHtcbiAgcmV0dXJuIHtcbiAgICBsYWJlbHM6IGRhdGFQb2ludHMubWFwKGRwID0+IGRwLnRpbWVzdGFtcC50b0lTT1N0cmluZygpKSxcbiAgICB2YWx1ZXM6IGRhdGFQb2ludHMubWFwKGRwID0+IGRwLnZhbHVlKSxcbiAgICBjaGFydFR5cGU6ICdsaW5lJyxcbiAgfTtcbn1cblxuLyoqXG4gKiBBbmFseXplIGhlYWx0aCB0cmVuZHMgZm9yIGEgdXNlclxuICogR0VUIC9hcGkvdjEvaGVhbHRoL3RyZW5kcy97dXNlcklkfVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihldmVudDogQVBJR2F0ZXdheVByb3h5RXZlbnQpOiBQcm9taXNlPEFQSUdhdGV3YXlQcm94eVJlc3VsdD4ge1xuICB0cnkge1xuICAgIC8vIEV4dHJhY3QgdXNlciBpbmZvIGZyb20gYXV0aG9yaXplciBjb250ZXh0XG4gICAgY29uc3QgcmVxdWVzdGluZ1VzZXJJZCA9IGV2ZW50LnJlcXVlc3RDb250ZXh0LmF1dGhvcml6ZXI/LnByaW5jaXBhbElkO1xuICAgIGNvbnN0IHJlcXVlc3RpbmdVc2VyVHlwZSA9IGV2ZW50LnJlcXVlc3RDb250ZXh0LmF1dGhvcml6ZXI/LnVzZXJUeXBlIGFzICdwcmltYXJ5JyB8ICdzZWNvbmRhcnknO1xuXG4gICAgaWYgKCFyZXF1ZXN0aW5nVXNlcklkIHx8ICFyZXF1ZXN0aW5nVXNlclR5cGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFcnJvclJlc3BvbnNlKDQwMSwgJ1VuYXV0aG9yaXplZDogTWlzc2luZyB1c2VyIGNvbnRleHQnKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGFyZ2V0IHVzZXIgSUQgZnJvbSBwYXRoIHBhcmFtZXRlcnNcbiAgICBjb25zdCB0YXJnZXRVc2VySWQgPSBldmVudC5wYXRoUGFyYW1ldGVycz8udXNlcklkO1xuXG4gICAgaWYgKCF0YXJnZXRVc2VySWQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFcnJvclJlc3BvbnNlKDQwMCwgJ01pc3NpbmcgdXNlcklkIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHBlcm1pc3Npb25zXG4gICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IGF3YWl0IGNoZWNrUGVybWlzc2lvbihcbiAgICAgIHJlcXVlc3RpbmdVc2VySWQsXG4gICAgICByZXF1ZXN0aW5nVXNlclR5cGUsXG4gICAgICB0YXJnZXRVc2VySWQsXG4gICAgICAndml0YWxzJyxcbiAgICAgICdyZWFkJ1xuICAgICk7XG5cbiAgICBpZiAoIWhhc1Blcm1pc3Npb24pIHtcbiAgICAgIGF3YWl0IGxvZ0RhdGFBY2Nlc3MoXG4gICAgICAgIHJlcXVlc3RpbmdVc2VySWQsXG4gICAgICAgIHJlcXVlc3RpbmdVc2VyVHlwZSxcbiAgICAgICAgdGFyZ2V0VXNlcklkLFxuICAgICAgICAndml0YWxzJyxcbiAgICAgICAgJ3JlYWQnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgWyd0cmVuZHMnXSxcbiAgICAgICAgeyByZWFzb246ICdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZSg0MDMsICdGb3JiaWRkZW46IEluc3VmZmljaWVudCBwZXJtaXNzaW9ucycpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHRpbWUgcmFuZ2UgZnJvbSBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgY29uc3QgdGltZVJhbmdlUGFyYW0gPSBldmVudC5xdWVyeVN0cmluZ1BhcmFtZXRlcnM/LnRpbWVSYW5nZSB8fCAnN2QnO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBzdGFydFRpbWU6IERhdGU7XG5cbiAgICBzd2l0Y2ggKHRpbWVSYW5nZVBhcmFtKSB7XG4gICAgICBjYXNlICcyNGgnOlxuICAgICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZShlbmRUaW1lLmdldFRpbWUoKSAtIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzdkJzpcbiAgICAgICAgc3RhcnRUaW1lID0gbmV3IERhdGUoZW5kVGltZS5nZXRUaW1lKCkgLSA3ICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMzBkJzpcbiAgICAgICAgc3RhcnRUaW1lID0gbmV3IERhdGUoZW5kVGltZS5nZXRUaW1lKCkgLSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzkwZCc6XG4gICAgICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKGVuZFRpbWUuZ2V0VGltZSgpIC0gOTAgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZShlbmRUaW1lLmdldFRpbWUoKSAtIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lUmFuZ2U6IFRpbWVSYW5nZSA9IHsgc3RhcnQ6IHN0YXJ0VGltZSwgZW5kOiBlbmRUaW1lIH07XG5cbiAgICAvLyBRdWVyeSB2aXRhbCBzaWducyBkYXRhXG4gICAgY29uc3Qgdml0YWxTaWduc0RhdGEgPSBhd2FpdCBxdWVyeVZpdGFsU2lnbnModGFyZ2V0VXNlcklkLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuXG4gICAgLy8gR3JvdXAgZGF0YSBieSBtZWFzdXJlIG5hbWVcbiAgICBjb25zdCBncm91cGVkRGF0YTogUmVjb3JkPHN0cmluZywgQXJyYXk8eyB0aW1lc3RhbXA6IERhdGU7IHZhbHVlOiBudW1iZXI7IHNvdXJjZTogc3RyaW5nIH0+PiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCByZWNvcmQgb2Ygdml0YWxTaWduc0RhdGEpIHtcbiAgICAgIGNvbnN0IG1lYXN1cmVOYW1lID0gcmVjb3JkLm1lYXN1cmVfbmFtZTtcbiAgICAgIGlmICghZ3JvdXBlZERhdGFbbWVhc3VyZU5hbWVdKSB7XG4gICAgICAgIGdyb3VwZWREYXRhW21lYXN1cmVOYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgZ3JvdXBlZERhdGFbbWVhc3VyZU5hbWVdLnB1c2goe1xuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHJlY29yZC50aW1lKSxcbiAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQocmVjb3JkLnZhbHVlKSxcbiAgICAgICAgc291cmNlOiByZWNvcmQuc291cmNlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgdHJlbmRzIGZvciBlYWNoIG1ldHJpY1xuICAgIGNvbnN0IHRyZW5kczogSGVhbHRoVHJlbmRbXSA9IFtdO1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW21ldHJpYywgZGF0YVBvaW50c10gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXBlZERhdGEpKSB7XG4gICAgICBpZiAoZGF0YVBvaW50cy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAvLyBTb3J0IGJ5IHRpbWVzdGFtcFxuICAgICAgZGF0YVBvaW50cy5zb3J0KChhLCBiKSA9PiBhLnRpbWVzdGFtcC5nZXRUaW1lKCkgLSBiLnRpbWVzdGFtcC5nZXRUaW1lKCkpO1xuXG4gICAgICBjb25zdCB0cmVuZCA9IGNhbGN1bGF0ZVRyZW5kKGRhdGFQb2ludHMpO1xuICAgICAgY29uc3QgYW5hbHlzaXMgPSBnZW5lcmF0ZUFuYWx5c2lzKG1ldHJpYywgdHJlbmQsIGRhdGFQb2ludHMpO1xuXG4gICAgICB0cmVuZHMucHVzaCh7XG4gICAgICAgIG1ldHJpYyxcbiAgICAgICAgdGltZVJhbmdlLFxuICAgICAgICBkYXRhUG9pbnRzOiBkYXRhUG9pbnRzLm1hcChkcCA9PiAoe1xuICAgICAgICAgIHRpbWVzdGFtcDogZHAudGltZXN0YW1wLFxuICAgICAgICAgIHZhbHVlOiBkcC52YWx1ZSxcbiAgICAgICAgICBzb3VyY2U6IGRwLnNvdXJjZSBhcyBhbnksXG4gICAgICAgIH0pKSxcbiAgICAgICAgdHJlbmQsXG4gICAgICAgIGFuYWx5c2lzLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIHJlY29tbWVuZGF0aW9ucyBmb3IgY29uY2VybmluZyB0cmVuZHNcbiAgICAgIGlmICh0cmVuZCA9PT0gJ2NvbmNlcm5pbmcnIHx8IHRyZW5kID09PSAnZGVjbGluaW5nJykge1xuICAgICAgICByZWNvbW1lbmRhdGlvbnMucHVzaChgTW9uaXRvciAke21ldHJpYy5yZXBsYWNlKC9fL2csICcgJyl9IGNsb3NlbHkgYW5kIGNvbnN1bHQgeW91ciBoZWFsdGhjYXJlIHByb3ZpZGVyLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHZpc3VhbGl6YXRpb24gZGF0YVxuICAgIGNvbnN0IHZpc3VhbGl6YXRpb25zID0gT2JqZWN0LmVudHJpZXMoZ3JvdXBlZERhdGEpLm1hcCgoW21ldHJpYywgZGF0YVBvaW50c10pID0+ICh7XG4gICAgICBtZXRyaWMsXG4gICAgICBkYXRhOiBnZW5lcmF0ZVZpc3VhbGl6YXRpb25EYXRhKGRhdGFQb2ludHMpLFxuICAgIH0pKTtcblxuICAgIC8vIExvZyBzdWNjZXNzZnVsIGFjY2Vzc1xuICAgIGF3YWl0IGxvZ0RhdGFBY2Nlc3MoXG4gICAgICByZXF1ZXN0aW5nVXNlcklkLFxuICAgICAgcmVxdWVzdGluZ1VzZXJUeXBlLFxuICAgICAgdGFyZ2V0VXNlcklkLFxuICAgICAgJ3ZpdGFscycsXG4gICAgICAncmVhZCcsXG4gICAgICB0cnVlLFxuICAgICAgWyd0cmVuZHMnXSxcbiAgICAgIHtcbiAgICAgICAgdGltZVJhbmdlOiB0aW1lUmFuZ2VQYXJhbSxcbiAgICAgICAgbWV0cmljc0FuYWx5emVkOiBPYmplY3Qua2V5cyhncm91cGVkRGF0YSksXG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBjcmVhdGVTdWNjZXNzUmVzcG9uc2Uoe1xuICAgICAgdXNlcklkOiB0YXJnZXRVc2VySWQsXG4gICAgICB0aW1lUmFuZ2U6IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0VGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICBlbmQ6IGVuZFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgIH0sXG4gICAgICB0cmVuZHMsXG4gICAgICB2aXN1YWxpemF0aW9ucyxcbiAgICAgIHJlY29tbWVuZGF0aW9ucyxcbiAgICAgIHN1bW1hcnk6IGBBbmFseXplZCAke3RyZW5kcy5sZW5ndGh9IGhlYWx0aCBtZXRyaWNzIG92ZXIgJHt0aW1lUmFuZ2VQYXJhbX1gLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0FuYWx5emUgaGVhbHRoIHRyZW5kcyBlcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yUmVzcG9uc2UoNTAwLCAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyk7XG4gIH1cbn1cbiJdfQ==