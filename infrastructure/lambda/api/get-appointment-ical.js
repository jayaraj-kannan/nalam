"use strict";
// Get Appointment iCal Lambda Function
// Requirements: 6.3
// Generates iCal format for calendar integration
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = handler;
const appointments_1 = require("../shared/data-access/appointments");
const types_1 = require("../shared/types");
/**
 * Generate iCal format for a single appointment
 */
function generateICalEvent(appointment) {
    const now = new Date();
    const dtStamp = formatICalDate(now);
    const dtStart = formatICalDate(appointment.scheduledTime);
    // Calculate end time (use duration or default to 30 minutes)
    const duration = appointment.duration || 30;
    const endTime = new Date(appointment.scheduledTime.getTime() + duration * 60 * 1000);
    const dtEnd = formatICalDate(endTime);
    // Escape special characters in text fields
    const summary = escapeICalText(`${appointment.type} - ${appointment.provider.name}`);
    const description = escapeICalText(`Appointment Type: ${appointment.type}\n` +
        `Provider: ${appointment.provider.name}\n` +
        `Specialty: ${appointment.provider.specialty}\n` +
        (appointment.notes ? `\nNotes: ${appointment.notes}` : '') +
        (appointment.preparationInstructions ? `\n\nPreparation: ${appointment.preparationInstructions}` : ''));
    const location = appointment.location ? escapeICalText(appointment.location) : '';
    // Generate alarm for reminders (24 hours and 2 hours before)
    const alarms = appointment.reminders.enabled
        ? appointment.reminders.times.map(hours => generateICalAlarm(hours)).join('\n')
        : '';
    return `BEGIN:VEVENT
UID:${appointment.id}@healthcare-monitoring.com
DTSTAMP:${dtStamp}
DTSTART:${dtStart}
DTEND:${dtEnd}
SUMMARY:${summary}
DESCRIPTION:${description}
LOCATION:${location}
STATUS:${appointment.status.toUpperCase()}
${alarms}
END:VEVENT`;
}
/**
 * Generate iCal alarm component
 */
function generateICalAlarm(hoursBefore) {
    const minutes = hoursBefore * 60;
    return `BEGIN:VALARM
ACTION:DISPLAY
DESCRIPTION:Appointment Reminder
TRIGGER:-PT${minutes}M
END:VALARM`;
}
/**
 * Format date for iCal (YYYYMMDDTHHMMSSZ)
 */
function formatICalDate(date) {
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    const hours = String(date.getUTCHours()).padStart(2, '0');
    const minutes = String(date.getUTCMinutes()).padStart(2, '0');
    const seconds = String(date.getUTCSeconds()).padStart(2, '0');
    return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
}
/**
 * Escape special characters for iCal text fields
 */
function escapeICalText(text) {
    return text
        .replace(/\\/g, '\\\\')
        .replace(/;/g, '\\;')
        .replace(/,/g, '\\,')
        .replace(/\n/g, '\\n');
}
/**
 * Generate complete iCal calendar
 */
function generateICalCalendar(appointments) {
    const events = appointments.map(apt => generateICalEvent(apt)).join('\n');
    return `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Healthcare Monitoring App//Appointment Calendar//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:Healthcare Appointments
X-WR-TIMEZONE:UTC
X-WR-CALDESC:Medical appointments from Healthcare Monitoring App
${events}
END:VCALENDAR`;
}
async function handler(event) {
    try {
        console.log('Get appointment iCal request:', JSON.stringify(event));
        // Get userId from path parameters
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return (0, types_1.createErrorResponse)(400, 'userId is required');
        }
        // Check if requesting single appointment or all appointments
        const appointmentId = event.pathParameters?.appointmentId;
        let appointments;
        if (appointmentId) {
            // Get single appointment
            const appointment = await (0, appointments_1.getAppointment)(userId, appointmentId);
            if (!appointment) {
                return (0, types_1.createErrorResponse)(404, 'Appointment not found');
            }
            appointments = [appointment];
        }
        else {
            // Get all appointments for user
            appointments = await (0, appointments_1.getAppointmentsByUser)(userId);
            // Filter to only scheduled and confirmed appointments
            appointments = appointments.filter(apt => apt.status === 'scheduled' || apt.status === 'confirmed');
        }
        // Generate iCal format
        const iCalContent = generateICalCalendar(appointments);
        // Return iCal file
        return {
            statusCode: 200,
            headers: {
                'Content-Type': 'text/calendar; charset=utf-8',
                'Content-Disposition': appointmentId
                    ? `attachment; filename="appointment-${appointmentId}.ics"`
                    : `attachment; filename="appointments-${userId}.ics"`,
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Credentials': true,
            },
            body: iCalContent,
        };
    }
    catch (error) {
        console.error('Error generating iCal:', error);
        return (0, types_1.createErrorResponse)(500, 'Failed to generate calendar file');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWFwcG9pbnRtZW50LWljYWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJnZXQtYXBwb2ludG1lbnQtaWNhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsdUNBQXVDO0FBQ3ZDLG9CQUFvQjtBQUNwQixpREFBaUQ7O0FBc0dqRCwwQkFvREM7QUF2SkQscUVBQTJGO0FBQzNGLDJDQUF5RTtBQUV6RTs7R0FFRztBQUNILFNBQVMsaUJBQWlCLENBQUMsV0FBOEI7SUFDdkQsTUFBTSxHQUFHLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUN2QixNQUFNLE9BQU8sR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEMsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUUxRCw2REFBNkQ7SUFDN0QsTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUM7SUFDNUMsTUFBTSxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsR0FBRyxRQUFRLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3JGLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUV0QywyQ0FBMkM7SUFDM0MsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLEdBQUcsV0FBVyxDQUFDLElBQUksTUFBTSxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDckYsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUNoQyxxQkFBcUIsV0FBVyxDQUFDLElBQUksSUFBSTtRQUN6QyxhQUFhLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJO1FBQzFDLGNBQWMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUk7UUFDaEQsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxZQUFZLFdB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LG9CQUFvQixDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXZELG1CQUFtQjtRQUNuQixPQUFPO1lBQ0wsVUFBVSxFQUFFLEdBQUc7WUFDZixPQUFPLEVBQUU7Z0JBQ1AsY0FBYyxFQUFFLDhCQUE4QjtnQkFDOUMscUJBQXFCLEVBQUUsYUFBYTtvQkFDbEMsQ0FBQyxDQUFDLHFDQUFxQyxhQUFhLE9BQU87b0JBQzNELENBQUMsQ0FBQyxzQ0FBc0MsTUFBTSxPQUFPO2dCQUN2RCw2QkFBNkIsRUFBRSxHQUFHO2dCQUNsQyxrQ0FBa0MsRUFBRSxJQUFJO2FBQ3pDO1lBQ0QsSUFBSSxFQUFFLFdBQVc7U0FDbEIsQ0FBQztJQUNKLENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMvQyxPQUFPLElBQUEsMkJBQW1CLEVBQUMsR0FBRyxFQUFFLGtDQUFrQyxDQUFDLENBQUM7SUFDdEUsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZXQgQXBwb2ludG1lbnQgaUNhbCBMYW1iZGEgRnVuY3Rpb25cbi8vIFJlcXVpcmVtZW50czogNi4zXG4vLyBHZW5lcmF0ZXMgaUNhbCBmb3JtYXQgZm9yIGNhbGVuZGFyIGludGVncmF0aW9uXG5cbmltcG9ydCB7IEFQSUdhdGV3YXlQcm94eUV2ZW50LCBBUElHYXRld2F5UHJveHlSZXN1bHQgfSBmcm9tICdhd3MtbGFtYmRhJztcbmltcG9ydCB7IGdldEFwcG9pbnRtZW50LCBnZXRBcHBvaW50bWVudHNCeVVzZXIgfSBmcm9tICcuLi9zaGFyZWQvZGF0YS1hY2Nlc3MvYXBwb2ludG1lbnRzJztcbmltcG9ydCB7IGNyZWF0ZUVycm9yUmVzcG9uc2UsIEFwcG9pbnRtZW50UmVjb3JkIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBpQ2FsIGZvcm1hdCBmb3IgYSBzaW5nbGUgYXBwb2ludG1lbnRcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJQ2FsRXZlbnQoYXBwb2ludG1lbnQ6IEFwcG9pbnRtZW50UmVjb3JkKTogc3RyaW5nIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgZHRTdGFtcCA9IGZvcm1hdElDYWxEYXRlKG5vdyk7XG4gIGNvbnN0IGR0U3RhcnQgPSBmb3JtYXRJQ2FsRGF0ZShhcHBvaW50bWVudC5zY2hlZHVsZWRUaW1lKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBlbmQgdGltZSAodXNlIGR1cmF0aW9uIG9yIGRlZmF1bHQgdG8gMzAgbWludXRlcylcbiAgY29uc3QgZHVyYXRpb24gPSBhcHBvaW50bWVudC5kdXJhdGlvbiB8fCAzMDtcbiAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKGFwcG9pbnRtZW50LnNjaGVkdWxlZFRpbWUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiA2MCAqIDEwMDApO1xuICBjb25zdCBkdEVuZCA9IGZvcm1hdElDYWxEYXRlKGVuZFRpbWUpO1xuXG4gIC8vIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGV4dCBmaWVsZHNcbiAgY29uc3Qgc3VtbWFyeSA9IGVzY2FwZUlDYWxUZXh0KGAke2FwcG9pbnRtZW50LnR5cGV9IC0gJHthcHBvaW50bWVudC5wcm92aWRlci5uYW1lfWApO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IGVzY2FwZUlDYWxUZXh0KFxuICAgIGBBcHBvaW50bWVudCBUeXBlOiAke2FwcG9pbnRtZW50LnR5cGV9XFxuYCArXG4gICAgYFByb3ZpZGVyOiAke2FwcG9pbnRtZW50LnByb3ZpZGVyLm5hbWV9XFxuYCArXG4gICAgYFNwZWNpYWx0eTogJHthcHBvaW50bWVudC5wcm92aWRlci5zcGVjaWFsdHl9XFxuYCArXG4gICAgKGFwcG9pbnRtZW50Lm5vdGVzID8gYFxcbk5vdGVzOiAke2FwcG9pbnRtZW50Lm5vdGVzfWAgOiAnJykgK1xuICAgIChhcHBvaW50bWVudC5wcmVwYXJhdGlvbkluc3RydWN0aW9ucyA/IGBcXG5cXG5QcmVwYXJhdGlvbjogJHthcHBvaW50bWVudC5wcmVwYXJhdGlvbkluc3RydWN0aW9uc31gIDogJycpXG4gICk7XG4gIGNvbnN0IGxvY2F0aW9uID0gYXBwb2ludG1lbnQubG9jYXRpb24gPyBlc2NhcGVJQ2FsVGV4dChhcHBvaW50bWVudC5sb2NhdGlvbikgOiAnJztcblxuICAvLyBHZW5lcmF0ZSBhbGFybSBmb3IgcmVtaW5kZXJzICgyNCBob3VycyBhbmQgMiBob3VycyBiZWZvcmUpXG4gIGNvbnN0IGFsYXJtcyA9IGFwcG9pbnRtZW50LnJlbWluZGVycy5lbmFibGVkXG4gICAgPyBhcHBvaW50bWVudC5yZW1pbmRlcnMudGltZXMubWFwKGhvdXJzID0+IGdlbmVyYXRlSUNhbEFsYXJtKGhvdXJzKSkuam9pbignXFxuJylcbiAgICA6ICcnO1xuXG4gIHJldHVybiBgQkVHSU46VkVWRU5UXG5VSUQ6JHthcHBvaW50bWVudC5pZH1AaGVhbHRoY2FyZS1tb25pdG9yaW5nLmNvbVxuRFRTVEFNUDoke2R0U3RhbXB9XG5EVFNUQVJUOiR7ZHRTdGFydH1cbkRURU5EOiR7ZHRFbmR9XG5TVU1NQVJZOiR7c3VtbWFyeX1cbkRFU0NSSVBUSU9OOiR7ZGVzY3JpcHRpb259XG5MT0NBVElPTjoke2xvY2F0aW9ufVxuU1RBVFVTOiR7YXBwb2ludG1lbnQuc3RhdHVzLnRvVXBwZXJDYXNlKCl9XG4ke2FsYXJtc31cbkVORDpWRVZFTlRgO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGlDYWwgYWxhcm0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSUNhbEFsYXJtKGhvdXJzQmVmb3JlOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBtaW51dGVzID0gaG91cnNCZWZvcmUgKiA2MDtcbiAgcmV0dXJuIGBCRUdJTjpWQUxBUk1cbkFDVElPTjpESVNQTEFZXG5ERVNDUklQVElPTjpBcHBvaW50bWVudCBSZW1pbmRlclxuVFJJR0dFUjotUFQke21pbnV0ZXN9TVxuRU5EOlZBTEFSTWA7XG59XG5cbi8qKlxuICogRm9ybWF0IGRhdGUgZm9yIGlDYWwgKFlZWVlNTUREVEhITU1TU1opXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElDYWxEYXRlKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICBjb25zdCBtb250aCA9IFN0cmluZyhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICBjb25zdCBkYXkgPSBTdHJpbmcoZGF0ZS5nZXRVVENEYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gIGNvbnN0IGhvdXJzID0gU3RyaW5nKGRhdGUuZ2V0VVRDSG91cnMoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgY29uc3QgbWludXRlcyA9IFN0cmluZyhkYXRlLmdldFVUQ01pbnV0ZXMoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgY29uc3Qgc2Vjb25kcyA9IFN0cmluZyhkYXRlLmdldFVUQ1NlY29uZHMoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgcmV0dXJuIGAke3llYXJ9JHttb250aH0ke2RheX1UJHtob3Vyc30ke21pbnV0ZXN9JHtzZWNvbmRzfVpgO1xufVxuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgZm9yIGlDYWwgdGV4dCBmaWVsZHNcbiAqL1xuZnVuY3Rpb24gZXNjYXBlSUNhbFRleHQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKVxuICAgIC5yZXBsYWNlKC87L2csICdcXFxcOycpXG4gICAgLnJlcGxhY2UoLywvZywgJ1xcXFwsJylcbiAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGNvbXBsZXRlIGlDYWwgY2FsZW5kYXJcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJQ2FsQ2FsZW5kYXIoYXBwb2ludG1lbnRzOiBBcHBvaW50bWVudFJlY29yZFtdKTogc3RyaW5nIHtcbiAgY29uc3QgZXZlbnRzID0gYXBwb2ludG1lbnRzLm1hcChhcHQgPT4gZ2VuZXJhdGVJQ2FsRXZlbnQoYXB0KSkuam9pbignXFxuJyk7XG4gIFxuICByZXR1cm4gYEJFR0lOOlZDQUxFTkRBUlxuVkVSU0lPTjoyLjBcblBST0RJRDotLy9IZWFsdGhjYXJlIE1vbml0b3JpbmcgQXBwLy9BcHBvaW50bWVudCBDYWxlbmRhci8vRU5cbkNBTFNDQUxFOkdSRUdPUklBTlxuTUVUSE9EOlBVQkxJU0hcblgtV1ItQ0FMTkFNRTpIZWFsdGhjYXJlIEFwcG9pbnRtZW50c1xuWC1XUi1USU1FWk9ORTpVVENcblgtV1ItQ0FMREVTQzpNZWRpY2FsIGFwcG9pbnRtZW50cyBmcm9tIEhlYWx0aGNhcmUgTW9uaXRvcmluZyBBcHBcbiR7ZXZlbnRzfVxuRU5EOlZDQUxFTkRBUmA7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50OiBBUElHYXRld2F5UHJveHlFdmVudCk6IFByb21pc2U8QVBJR2F0ZXdheVByb3h5UmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0dldCBhcHBvaW50bWVudCBpQ2FsIHJlcXVlc3Q6JywgSlNPTi5zdHJpbmdpZnkoZXZlbnQpKTtcblxuICAgIC8vIEdldCB1c2VySWQgZnJvbSBwYXRoIHBhcmFtZXRlcnNcbiAgICBjb25zdCB1c2VySWQgPSBldmVudC5wYXRoUGFyYW1ldGVycz8udXNlcklkO1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZSg0MDAsICd1c2VySWQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiByZXF1ZXN0aW5nIHNpbmdsZSBhcHBvaW50bWVudCBvciBhbGwgYXBwb2ludG1lbnRzXG4gICAgY29uc3QgYXBwb2ludG1lbnRJZCA9IGV2ZW50LnBhdGhQYXJhbWV0ZXJzPy5hcHBvaW50bWVudElkO1xuICAgIFxuICAgIGxldCBhcHBvaW50bWVudHM6IEFwcG9pbnRtZW50UmVjb3JkW107XG5cbiAgICBpZiAoYXBwb2ludG1lbnRJZCkge1xuICAgICAgLy8gR2V0IHNpbmdsZSBhcHBvaW50bWVudFxuICAgICAgY29uc3QgYXBwb2ludG1lbnQgPSBhd2FpdCBnZXRBcHBvaW50bWVudCh1c2VySWQsIGFwcG9pbnRtZW50SWQpO1xuICAgICAgaWYgKCFhcHBvaW50bWVudCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZSg0MDQsICdBcHBvaW50bWVudCBub3QgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGFwcG9pbnRtZW50cyA9IFthcHBvaW50bWVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdldCBhbGwgYXBwb2ludG1lbnRzIGZvciB1c2VyXG4gICAgICBhcHBvaW50bWVudHMgPSBhd2FpdCBnZXRBcHBvaW50bWVudHNCeVVzZXIodXNlcklkKTtcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIHRvIG9ubHkgc2NoZWR1bGVkIGFuZCBjb25maXJtZWQgYXBwb2ludG1lbnRzXG4gICAgICBhcHBvaW50bWVudHMgPSBhcHBvaW50bWVudHMuZmlsdGVyKFxuICAgICAgICBhcHQgPT4gYXB0LnN0YXR1cyA9PT0gJ3NjaGVkdWxlZCcgfHwgYXB0LnN0YXR1cyA9PT0gJ2NvbmZpcm1lZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgaUNhbCBmb3JtYXRcbiAgICBjb25zdCBpQ2FsQ29udGVudCA9IGdlbmVyYXRlSUNhbENhbGVuZGFyKGFwcG9pbnRtZW50cyk7XG5cbiAgICAvLyBSZXR1cm4gaUNhbCBmaWxlXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2NhbGVuZGFyOyBjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nOiBhcHBvaW50bWVudElkIFxuICAgICAgICAgID8gYGF0dGFjaG1lbnQ7IGZpbGVuYW1lPVwiYXBwb2ludG1lbnQtJHthcHBvaW50bWVudElkfS5pY3NcImBcbiAgICAgICAgICA6IGBhdHRhY2htZW50OyBmaWxlbmFtZT1cImFwcG9pbnRtZW50cy0ke3VzZXJJZH0uaWNzXCJgLFxuICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHMnOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IGlDYWxDb250ZW50LFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBpQ2FsOicsIGVycm9yKTtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZSg1MDAsICdGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsZW5kYXIgZmlsZScpO1xuICB9XG59XG4iXX0=