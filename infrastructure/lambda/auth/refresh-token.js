"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_cognito_identity_provider_1 = require("@aws-sdk/client-cognito-identity-provider");
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const types_1 = require("../shared/types");
const cognitoClient = new client_cognito_identity_provider_1.CognitoIdentityProviderClient({});
const dynamoClient = lib_dynamodb_1.DynamoDBDocumentClient.from(new client_dynamodb_1.DynamoDBClient({}));
const PRIMARY_USER_POOL_CLIENT_ID = process.env.PRIMARY_USER_POOL_CLIENT_ID;
const SECONDARY_USER_POOL_CLIENT_ID = process.env.SECONDARY_USER_POOL_CLIENT_ID;
const USERS_TABLE = process.env.USERS_TABLE;
const handler = async (event) => {
    try {
        if (!event.body) {
            return (0, types_1.createErrorResponse)(400, 'Request body is required');
        }
        const request = JSON.parse(event.body);
        const { refreshToken, userType } = request;
        // Validate required fields
        if (!refreshToken || !userType) {
            return (0, types_1.createErrorResponse)(400, 'Missing required fields: refreshToken, userType');
        }
        if (!['primary', 'secondary'].includes(userType)) {
            return (0, types_1.createErrorResponse)(400, 'userType must be either "primary" or "secondary"');
        }
        // Select appropriate user pool client based on user type
        const clientId = userType === 'primary' ? PRIMARY_USER_POOL_CLIENT_ID : SECONDARY_USER_POOL_CLIENT_ID;
        // Refresh the token
        const refreshCommand = new client_cognito_identity_provider_1.InitiateAuthCommand({
            AuthFlow: 'REFRESH_TOKEN_AUTH',
            ClientId: clientId,
            AuthParameters: {
                REFRESH_TOKEN: refreshToken,
            },
        });
        const refreshResult = await cognitoClient.send(refreshCommand);
        if (!refreshResult.AuthenticationResult) {
            return (0, types_1.createErrorResponse)(401, 'Token refresh failed');
        }
        const { AccessToken, IdToken, ExpiresIn } = refreshResult.AuthenticationResult;
        // Get user details to update last active
        const getUserCommand = new client_cognito_identity_provider_1.GetUserCommand({
            AccessToken: AccessToken,
        });
        const userDetails = await cognitoClient.send(getUserCommand);
        const userId = userDetails.UserAttributes?.find(attr => attr.Name === 'sub')?.Value;
        // Update last active timestamp in DynamoDB
        if (userId) {
            await dynamoClient.send(new lib_dynamodb_1.UpdateCommand({
                TableName: USERS_TABLE,
                Key: { userId },
                UpdateExpression: 'SET lastActive = :timestamp',
                ExpressionAttributeValues: {
                    ':timestamp': new Date().toISOString(),
                },
            }));
        }
        return (0, types_1.createSuccessResponse)({
            accessToken: AccessToken,
            idToken: IdToken,
            expiresIn: ExpiresIn,
            userId,
            message: 'Token refreshed successfully',
        });
    }
    catch (error) {
        console.error('Token refresh error:', error);
        // Handle specific Cognito errors
        if (error.name === 'NotAuthorizedException') {
            return (0, types_1.createErrorResponse)(401, 'Invalid or expired refresh token. Please log in again.');
        }
        if (error.name === 'TooManyRequestsException') {
            return (0, types_1.createErrorResponse)(429, 'Too many requests. Please try again later.');
        }
        return (0, types_1.createErrorResponse)(500, 'Token refresh failed. Please try again.');
    }
};
exports.handler = handler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVmcmVzaC10b2tlbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJlZnJlc2gtdG9rZW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsZ0dBQStIO0FBQy9ILDhEQUEwRDtBQUMxRCx3REFBOEU7QUFDOUUsMkNBQTZFO0FBRTdFLE1BQU0sYUFBYSxHQUFHLElBQUksZ0VBQTZCLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDNUQsTUFBTSxZQUFZLEdBQUcscUNBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksZ0NBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRXpFLE1BQU0sMkJBQTJCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQywyQkFBNEIsQ0FBQztBQUM3RSxNQUFNLDZCQUE2QixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkJBQThCLENBQUM7QUFDakYsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFZLENBQUM7QUFPdEMsTUFBTSxPQUFPLEdBQUcsS0FBSyxFQUFFLEtBQTJCLEVBQWtDLEVBQUU7SUFDM0YsSUFBSSxDQUFDO1FBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNoQixPQUFPLElBQUEsMkJBQW1CLEVBQUMsR0FBRyxFQUFFLDBCQUEwQixDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUF3QixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1RCxNQUFNLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUUzQywyQkFBMkI7UUFDM0IsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQy9CLE9BQU8sSUFBQSwyQkFBbUIsRUFBQyxHQUFHLEVBQUUsaURBQWlELENBQUMsQ0FBQztRQUNyRixDQUFDO1FBRUQsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1lBQ2pELE9BQU8sSUFBQSwyQkFBbUIsRUFBQyxHQUFHLEVBQUUsa0RBQWtELENBQUMsQ0FBQztRQUN0RixDQUFDO1FBRUQseURBQXlEO1FBQ3pELE1BQU0sUUFBUSxHQUFHLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQyw2QkFBNkIsQ0FBQztRQUV0RyxvQkFBb0I7UUFDcEIsTUFBTSxjQUFjLEdBQUcsSUFBSSxzREFBbUIsQ0FBQztZQUM3QyxRQUFRLEVBQUUsb0JBQW9CO1lBQzlCLFFBQVEsRUFBRSxRQUFRO1lBQ2xCLGNBQWMsRUFBRTtnQkFDZCxhQUFhLEVBQUUsWUFBWTthQUM1QjtTQUNGLENBQUMsQ0FBQztRQUVILE1BQU0sYUFBYSxHQUFHLE1BQU0sYUFBYSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUUvRCxJQUFJLENBQUMsYUFBYSxDQUFDLG9CQUFvQixFQUFFLENBQUM7WUFDeEMsT0FBTyxJQUFBLDJCQUFtQixFQUFDLEdBQUcsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1FBQzFELENBQUM7UUFFRCxNQUFNLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxhQUFhLENBQUMsb0JBQW9CLENBQUM7UUFFL0UseUNBQXlDO1FBQ3pDLE1BQU0sY0FBYyxHQUFHLElBQUksaURBQWMsQ0FBQztZQUN4QyxXQUFXLEVBQUUsV0FBWTtTQUMxQixDQUFDLENBQUM7UUFDSCxNQUFNLFdBQVcsR0FBRyxNQUFNLGFBQWEsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDN0QsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQztRQUVwRiwyQ0FBMkM7UUFDM0MsSUFBSSxNQUFNLEVBQUUsQ0FBQztZQUNYLE1BQU0sWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLDRCQUFhLENBQUM7Z0JBQ3hDLFNBQVMsRUFBRSxXQUFXO2dCQUN0QixHQUFHLEVBQUUsRUFBRSxNQUFNLEVBQUU7Z0JBQ2YsZ0JBQWdCLEVBQUUsNkJBQTZCO2dCQUMvQyx5QkFBeUIsRUFBRTtvQkFDekIsWUFBWSxFQUFFLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO2lCQUN2QzthQUNGLENBQUMsQ0FBQyxDQUFDO1FBQ04sQ0FBQztRQUVELE9BQU8sSUFBQSw2QkFBcUIsRUFBQztZQUMzQixXQUFXLEVBQUUsV0FBVztZQUN4QixPQUFPLEVBQUUsT0FBTztZQUNoQixTQUFTLEVBQUUsU0FBUztZQUNwQixNQUFNO1lBQ04sT0FBTyxFQUFFLDhCQUE4QjtTQUN4QyxDQUFDLENBQUM7SUFFTCxDQUFDO0lBQUMsT0FBTyxLQUFVLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsS0FBSyxDQUFDLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTdDLGlDQUFpQztRQUNqQyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssd0JBQXdCLEVBQUUsQ0FBQztZQUM1QyxPQUFPLElBQUEsMkJBQW1CLEVBQUMsR0FBRyxFQUFFLHdEQUF3RCxDQUFDLENBQUM7UUFDNUYsQ0FBQztRQUNELElBQUksS0FBSyxDQUFDLElBQUksS0FBSywwQkFBMEIsRUFBRSxDQUFDO1lBQzlDLE9BQU8sSUFBQSwyQkFBbUIsRUFBQyxHQUFHLEVBQUUsNENBQTRDLENBQUMsQ0FBQztRQUNoRixDQUFDO1FBRUQsT0FBTyxJQUFBLDJCQUFtQixFQUFDLEdBQUcsRUFBRSx5Q0FBeUMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7QUFDSCxDQUFDLENBQUM7QUE5RVcsUUFBQSxPQUFPLFdBOEVsQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSUdhdGV3YXlQcm94eUV2ZW50LCBBUElHYXRld2F5UHJveHlSZXN1bHQgfSBmcm9tICdhd3MtbGFtYmRhJztcbmltcG9ydCB7IENvZ25pdG9JZGVudGl0eVByb3ZpZGVyQ2xpZW50LCBJbml0aWF0ZUF1dGhDb21tYW5kLCBHZXRVc2VyQ29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jb2duaXRvLWlkZW50aXR5LXByb3ZpZGVyJztcbmltcG9ydCB7IER5bmFtb0RCQ2xpZW50IH0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWR5bmFtb2RiJztcbmltcG9ydCB7IER5bmFtb0RCRG9jdW1lbnRDbGllbnQsIFVwZGF0ZUNvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9saWItZHluYW1vZGInO1xuaW1wb3J0IHsgY3JlYXRlU3VjY2Vzc1Jlc3BvbnNlLCBjcmVhdGVFcnJvclJlc3BvbnNlIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuY29uc3QgY29nbml0b0NsaWVudCA9IG5ldyBDb2duaXRvSWRlbnRpdHlQcm92aWRlckNsaWVudCh7fSk7XG5jb25zdCBkeW5hbW9DbGllbnQgPSBEeW5hbW9EQkRvY3VtZW50Q2xpZW50LmZyb20obmV3IER5bmFtb0RCQ2xpZW50KHt9KSk7XG5cbmNvbnN0IFBSSU1BUllfVVNFUl9QT09MX0NMSUVOVF9JRCA9IHByb2Nlc3MuZW52LlBSSU1BUllfVVNFUl9QT09MX0NMSUVOVF9JRCE7XG5jb25zdCBTRUNPTkRBUllfVVNFUl9QT09MX0NMSUVOVF9JRCA9IHByb2Nlc3MuZW52LlNFQ09OREFSWV9VU0VSX1BPT0xfQ0xJRU5UX0lEITtcbmNvbnN0IFVTRVJTX1RBQkxFID0gcHJvY2Vzcy5lbnYuVVNFUlNfVEFCTEUhO1xuXG5pbnRlcmZhY2UgUmVmcmVzaFRva2VuUmVxdWVzdCB7XG4gIHJlZnJlc2hUb2tlbjogc3RyaW5nO1xuICB1c2VyVHlwZTogJ3ByaW1hcnknIHwgJ3NlY29uZGFyeSc7XG59XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyID0gYXN5bmMgKGV2ZW50OiBBUElHYXRld2F5UHJveHlFdmVudCk6IFByb21pc2U8QVBJR2F0ZXdheVByb3h5UmVzdWx0PiA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFldmVudC5ib2R5KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZSg0MDAsICdSZXF1ZXN0IGJvZHkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0OiBSZWZyZXNoVG9rZW5SZXF1ZXN0ID0gSlNPTi5wYXJzZShldmVudC5ib2R5KTtcbiAgICBjb25zdCB7IHJlZnJlc2hUb2tlbiwgdXNlclR5cGUgfSA9IHJlcXVlc3Q7XG5cbiAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICBpZiAoIXJlZnJlc2hUb2tlbiB8fCAhdXNlclR5cGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFcnJvclJlc3BvbnNlKDQwMCwgJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiByZWZyZXNoVG9rZW4sIHVzZXJUeXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10uaW5jbHVkZXModXNlclR5cGUpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZSg0MDAsICd1c2VyVHlwZSBtdXN0IGJlIGVpdGhlciBcInByaW1hcnlcIiBvciBcInNlY29uZGFyeVwiJyk7XG4gICAgfVxuXG4gICAgLy8gU2VsZWN0IGFwcHJvcHJpYXRlIHVzZXIgcG9vbCBjbGllbnQgYmFzZWQgb24gdXNlciB0eXBlXG4gICAgY29uc3QgY2xpZW50SWQgPSB1c2VyVHlwZSA9PT0gJ3ByaW1hcnknID8gUFJJTUFSWV9VU0VSX1BPT0xfQ0xJRU5UX0lEIDogU0VDT05EQVJZX1VTRVJfUE9PTF9DTElFTlRfSUQ7XG5cbiAgICAvLyBSZWZyZXNoIHRoZSB0b2tlblxuICAgIGNvbnN0IHJlZnJlc2hDb21tYW5kID0gbmV3IEluaXRpYXRlQXV0aENvbW1hbmQoe1xuICAgICAgQXV0aEZsb3c6ICdSRUZSRVNIX1RPS0VOX0FVVEgnLFxuICAgICAgQ2xpZW50SWQ6IGNsaWVudElkLFxuICAgICAgQXV0aFBhcmFtZXRlcnM6IHtcbiAgICAgICAgUkVGUkVTSF9UT0tFTjogcmVmcmVzaFRva2VuLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlZnJlc2hSZXN1bHQgPSBhd2FpdCBjb2duaXRvQ2xpZW50LnNlbmQocmVmcmVzaENvbW1hbmQpO1xuXG4gICAgaWYgKCFyZWZyZXNoUmVzdWx0LkF1dGhlbnRpY2F0aW9uUmVzdWx0KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZSg0MDEsICdUb2tlbiByZWZyZXNoIGZhaWxlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgQWNjZXNzVG9rZW4sIElkVG9rZW4sIEV4cGlyZXNJbiB9ID0gcmVmcmVzaFJlc3VsdC5BdXRoZW50aWNhdGlvblJlc3VsdDtcblxuICAgIC8vIEdldCB1c2VyIGRldGFpbHMgdG8gdXBkYXRlIGxhc3QgYWN0aXZlXG4gICAgY29uc3QgZ2V0VXNlckNvbW1hbmQgPSBuZXcgR2V0VXNlckNvbW1hbmQoe1xuICAgICAgQWNjZXNzVG9rZW46IEFjY2Vzc1Rva2VuISxcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyRGV0YWlscyA9IGF3YWl0IGNvZ25pdG9DbGllbnQuc2VuZChnZXRVc2VyQ29tbWFuZCk7XG4gICAgY29uc3QgdXNlcklkID0gdXNlckRldGFpbHMuVXNlckF0dHJpYnV0ZXM/LmZpbmQoYXR0ciA9PiBhdHRyLk5hbWUgPT09ICdzdWInKT8uVmFsdWU7XG5cbiAgICAvLyBVcGRhdGUgbGFzdCBhY3RpdmUgdGltZXN0YW1wIGluIER5bmFtb0RCXG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgYXdhaXQgZHluYW1vQ2xpZW50LnNlbmQobmV3IFVwZGF0ZUNvbW1hbmQoe1xuICAgICAgICBUYWJsZU5hbWU6IFVTRVJTX1RBQkxFLFxuICAgICAgICBLZXk6IHsgdXNlcklkIH0sXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdTRVQgbGFzdEFjdGl2ZSA9IDp0aW1lc3RhbXAnLFxuICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAgICAgJzp0aW1lc3RhbXAnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVN1Y2Nlc3NSZXNwb25zZSh7XG4gICAgICBhY2Nlc3NUb2tlbjogQWNjZXNzVG9rZW4sXG4gICAgICBpZFRva2VuOiBJZFRva2VuLFxuICAgICAgZXhwaXJlc0luOiBFeHBpcmVzSW4sXG4gICAgICB1c2VySWQsXG4gICAgICBtZXNzYWdlOiAnVG9rZW4gcmVmcmVzaGVkIHN1Y2Nlc3NmdWxseScsXG4gICAgfSk7XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZXJyb3I6JywgZXJyb3IpO1xuXG4gICAgLy8gSGFuZGxlIHNwZWNpZmljIENvZ25pdG8gZXJyb3JzXG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBdXRob3JpemVkRXhjZXB0aW9uJykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yUmVzcG9uc2UoNDAxLCAnSW52YWxpZCBvciBleHBpcmVkIHJlZnJlc2ggdG9rZW4uIFBsZWFzZSBsb2cgaW4gYWdhaW4uJyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5uYW1lID09PSAnVG9vTWFueVJlcXVlc3RzRXhjZXB0aW9uJykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yUmVzcG9uc2UoNDI5LCAnVG9vIG1hbnkgcmVxdWVzdHMuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yUmVzcG9uc2UoNTAwLCAnVG9rZW4gcmVmcmVzaCBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gIH1cbn07XG4iXX0=